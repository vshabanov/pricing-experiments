-- Generated by Claude in GitHub Copilot
{-# LANGUAGE TemplateHaskell #-}
module FreeVars where

import Control.Monad
import Data.Maybe
import Language.Haskell.TH
import Language.Haskell.TH.Syntax
import Language.Haskell.TH.Quote
import Data.Set (Set)
import qualified Data.Set as Set

-- | Extract free variables from a Template Haskell expression
getFreeVars :: Exp -> Q (Set Name)
getFreeVars expr = return $ freeVars Set.empty expr

singleton :: Name -> Set Name
singleton name
    | isJust (nameModule name) = Set.empty
    | otherwise = Set.singleton name

-- | Helper function that does the actual free variable collection
freeVars :: Set Name -> Exp -> Set Name
freeVars bound expr = case expr of
    -- Variables
    VarE name
        | name `Set.member` bound -> Set.empty  -- Bound variable
        | otherwise               -> singleton name  -- Free variable

    -- Unbound Variables (always free)
    UnboundVarE name -> singleton name

    -- Lambda abstractions
    LamE pats body ->
        let newBound = Set.union bound (Set.fromList $ concatMap patNames pats)
        in freeVars newBound body

    -- Let expressions
    LetE decs body ->
        let decNames = Set.fromList $ concatMap declNames decs
            newBound = Set.union bound decNames
            decVars = Set.unions $ map (freeVars newBound . declBody) decs
        in Set.union decVars (freeVars newBound body)
          `Set.difference` decNames

    -- Function application
    AppE (VarE n) _ | nameBase n == "id" -> Set.empty
    AppE e1 e2 -> Set.union (freeVars bound e1) (freeVars bound e2)

    -- Type application
    AppTypeE e _ -> freeVars bound e

    -- If expressions
    CondE e1 e2 e3 -> Set.unions [freeVars bound e1, freeVars bound e2, freeVars bound e3]

    -- Case expressions
    CaseE e matches ->
        Set.union (freeVars bound e) (Set.unions $ map (matchFreeVars bound) matches)

    -- Tuples
    TupE es -> Set.unions $ map (freeVars bound . fromJust) (filter isJust es)

    -- Unboxed tuples
    UnboxedTupE es -> Set.unions $ map (freeVars bound . fromJust) (filter isJust es)

    -- Unboxed sums
    UnboxedSumE e _ _ -> freeVars bound e

    -- Record construction
    RecConE _ fields -> Set.unions $ map (freeVars bound . snd) fields

    -- Record updates
    RecUpdE e fields -> Set.union (freeVars bound e) $
                       Set.unions $ map (freeVars bound . snd) fields

    -- Lists
    ListE es -> Set.unions $ map (freeVars bound) es

    -- Type signatures
    SigE e _ -> freeVars bound e

    -- Static expressions
    StaticE e -> freeVars bound e

    -- Arithmetic sequences
    ArithSeqE range -> rangeVars bound range

    -- Infix expressions
    InfixE me1 e me2 -> Set.unions
        [ maybe Set.empty (freeVars bound) me1
        , freeVars bound e
        , maybe Set.empty (freeVars bound) me2
        ]

    -- List comprehensions
    CompE stmts -> stmtsFreeVars bound stmts

    -- Do expressions
    DoE _ stmts -> stmtsFreeVars bound stmts

    -- Other expressions (literals, etc.)
    LitE _ -> Set.empty
    ConE _ -> Set.empty

    x -> error $ show x

-- | Helper function for arithmetic sequences
rangeVars :: Set Name -> Range -> Set Name
rangeVars bound range = case range of
    FromR e -> freeVars bound e
    FromThenR e1 e2 -> Set.union (freeVars bound e1) (freeVars bound e2)
    FromToR e1 e2 -> Set.union (freeVars bound e1) (freeVars bound e2)
    FromThenToR e1 e2 e3 -> Set.unions [freeVars bound e1, freeVars bound e2, freeVars bound e3]

-- | Extract all bound names from a pattern
patNames :: Pat -> [Name]
patNames pat = case pat of
    -- Variable pattern
    VarP name -> [name]
    -- Literal pattern
    LitP _ -> []
    -- Constructor pattern
    ConP _ _ pats -> concatMap patNames pats
    -- Record constructor pattern
    RecP _ fields -> concatMap (patNames . snd) fields
    -- Tuple pattern
    TupP pats -> concatMap patNames pats
    -- Unboxed tuple pattern
    UnboxedTupP pats -> concatMap patNames pats
    -- Unboxed sum pattern
    UnboxedSumP pat _ _ -> patNames pat
    -- List pattern
    ListP pats -> concatMap patNames pats
    -- As-pattern (e.g., x@(Just y))
    AsP name pat -> name : patNames pat
    -- Wildcard pattern (_)
    WildP -> []
    -- Strict pattern (!)
    BangP pat -> patNames pat
    -- Lazy pattern (~)
    TildeP pat -> patNames pat
    -- Type-annotated pattern
    SigP pat _ -> patNames pat
    -- View pattern
    ViewP _ pat -> patNames pat
    -- Infix constructor pattern
    InfixP pat1 _ pat2 -> concatMap patNames [pat1, pat2]
    -- Parenthesized pattern
    ParensP pat -> patNames pat

declNames :: Dec -> [Name]
declNames (ValD pat _ _) = patNames pat
declNames (FunD name _) = [name]
declNames _ = []

declBody :: Dec -> Exp
declBody (ValD _ b _) = bodyToExp b
declBody (FunD _ c) = ListE [LamE pat (bodyToExp b) | Clause pat b _ <- c]
declBody b = error $ "declBody: unsupported declaration " <> show b

matchFreeVars :: Set Name -> Match -> Set Name
matchFreeVars bound (Match pat body decs) =
    let boundNames = Set.union bound (Set.fromList $ patNames pat ++ concatMap declNames decs)
    in freeVars boundNames (bodyToExp body)

stmtsFreeVars :: Set Name -> [Stmt] -> Set Name
stmtsFreeVars bound [] = Set.empty
stmtsFreeVars bound (stmt:stmts) = case stmt of
    BindS pat expr ->
        let boundNames = Set.union bound (Set.fromList $ patNames pat)
        in Set.union (freeVars bound expr) (stmtsFreeVars boundNames stmts)
    LetS decs ->
        let boundNames = Set.union bound (Set.fromList $ concatMap declNames decs)
            decVars = Set.unions $ map (freeVars bound . declBody) decs
        in Set.union decVars (stmtsFreeVars boundNames stmts)
    NoBindS expr ->
        Set.union (freeVars bound expr) (stmtsFreeVars bound stmts)
    ParS stmtss ->
        Set.unions $ map (stmtsFreeVars bound) stmtss

bodyToExp :: Body -> Exp
bodyToExp (NormalB e) = e
bodyToExp (GuardedB guardedExps) =
    foldr mkGuardedExp (VarE (mkName "undefined")) guardedExps
  where
    mkGuardedExp (NormalG condExpr, resultExpr) elseExpr =
        CondE condExpr resultExpr elseExpr
    mkGuardedExp (PatG stmts, resultExpr) elseExpr =
        DoE Nothing (stmts ++ [NoBindS resultExpr])

{- | Capture free variables in an expression and return
     a tuple of (list of values, function that takes this list)

let x = 1
    y = 2
    (usedVars, func) = $(capture [| x + y + 3 |])
 -- (usedVars, func) = ([x, y], \[x,y] -> x + y + 3)
in func usedVars

-}
capture :: Q Exp -> Q Exp
capture qexpr = do
    expr <- qexpr
    let freeNames = Set.toList $ freeVars Set.empty expr
    let makeVarList = ListE (map VarE freeNames)
    let funcExpr = LamE [ListP (map VarP freeNames)] expr
    return $ TupE [Just makeVarList, Just funcExpr]

fitSystemQ :: Q Exp -> Q Exp -> Q Exp
fitSystemQ guesses qexpr = do
    expr <- qexpr
    let freeNames = Set.toList $ freeVars Set.empty expr
    let makeVarList = pure $ ListE (map VarE freeNames)
    let funcExpr = pure $ LamE [ListP (map VarP freeNames)] expr
    [| fitSystemThrow $makeVarList $guesses $funcExpr |]

fitSystemQ1 :: Q Exp -> Q Exp -> Q Exp
fitSystemQ1 guesses qexpr = do
    expr <- qexpr
    let freeNames = Set.toList $ freeVars Set.empty expr
    let makeVarList = pure $ ListE (map VarE freeNames)
    let funcExpr = pure $ LamE [ListP (map VarP freeNames)] expr
    [| fitSystemThrow1 $makeVarList $guesses $funcExpr |]
